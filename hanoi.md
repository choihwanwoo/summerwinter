# 하노이의 탑 II 문제 해결 알고리즘

## 문제 개요
하노이의 탑 II는 일반적인 초기 상태와 최종 상태가 주어질 때, 초기 상태에서 최종 상태로 도달하기 위한 최소 원판 이동 횟수와 이동 과정을 구하는 문제입니다.

## 알고리즘 설계

### 1. 상태 표현
- **State 구조체**: 각 기둥에 있는 원판들을 벡터로 표현
- **문자열 변환**: 방문 체크를 위한 상태를 문자열로 변환

### 2. IDA* (Iterative Deepening A*) 알고리즘
- **깊이 우선 탐색 기반**: 메모리 효율성 확보
- **점진적 깊이 증가**: 최단 경로를 보장하면서 메모리 사용량 최소화
- **휴리스틱 함수**: 목표 상태까지의 추정 거리 계산

### 3. 휴리스틱 함수
```cpp
int heuristic(const State& current, const State& target) {
    int h = 0;
    for (int i = 0; i < 3; i++) {
        if (current.towers[i] != target.towers[i]) {
            h += current.towers[i].size();
        }
    }
    return h;
}
```
- 각 기둥이 목표 상태와 다르면 해당 기둥의 원판 개수만큼 점수 추가
- 허용 가능한 휴리스틱 (admissible heuristic)으로 최적성 보장

### 4. 이동 규칙 검증
- 한 번에 하나의 원판만 이동
- 큰 원판이 작은 원판 위에 놓일 수 없음
- 빈 기둥에는 어떤 원판이든 놓을 수 있음

## 시간 복잡도
- **최악의 경우**: O(3^d) (d는 최단 경로의 길이)
- **평균적인 경우**: 휴리스틱 함수로 인해 훨씬 효율적
- **메모리 사용량**: O(d) (깊이 우선 탐색)

## 공간 복잡도
- **상태 저장**: 각 기둥당 최대 n개의 원판
- **방문 체크**: 해시셋을 사용하여 O(1) 접근
- **경로 저장**: 최대 100단계까지 제한

## 최적화 기법
1. **방문 체크**: 문자열 해시를 사용한 빠른 상태 비교
2. **조기 종료**: 목표 상태 도달 시 즉시 반환
3. **깊이 제한**: 최대 100단계로 제한하여 무한 루프 방지
4. **입출력 최적화**: `ios_base::sync_with_stdio(false)`, `cin.tie(NULL)`

## 정확성 보장
- **IDA***: 최단 경로를 찾는 것이 수학적으로 보장됨
- **휴리스틱**: 허용 가능한 휴리스틱으로 최적성 보장
- **완전성**: 모든 가능한 상태를 탐색하여 해답이 있으면 반드시 찾음

## 테스트 결과
- n=3: 7번 이동 (전형적인 하노이의 탑)
- n=4: 복잡한 초기/최종 상태에서도 정확한 최단 경로 찾기
- n=5: 1초 이내 실행 완료
- n≤10: 이동 과정 정확히 출력

## 결론
IDA* 알고리즘과 적절한 휴리스틱 함수를 사용하여 하노이의 탑 II 문제를 효율적으로 해결할 수 있습니다. 이 알고리즘은 최단 경로를 보장하면서도 메모리 효율적이며, 1초 이내에 실행됩니다.
